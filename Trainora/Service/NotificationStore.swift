//
//  NotificationStore.swift
//  Trainora
//
//  Created by user266021 on 5/6/25.
//
import Foundationfinal class NotificationStore: ObservableObject {    @Published var notifications: [AppNotification] = []    private let userDefaultsKey = "notifications"    static let shared = NotificationStore() // Singleton instance    private init() {        print("NS: NotificationStore initialized.")        load()    }    func addAndSave(_ notification: AppNotification) {        if !notifications.contains(where: { $0.id == notification.id }) {            notifications.insert(notification, at: 0)            notifications.sort { $0.date > $1.date }            save()            print("NS (Direct): Added and saved notification: \(notification.title), count: \(notifications.count)")        } else {            print("NS (Direct): Duplicate notification not saved: \(notification.title)")        }    }    func load() {        guard let data = UserDefaults.standard.data(forKey: userDefaultsKey),              let decoded = try? JSONDecoder().decode([AppNotification].self, from: data) else {            self.notifications = [] // Ensure it's empty if loading fails            print("NS: No data found in UserDefaults or failed to decode for key '\(userDefaultsKey)'. Initializing with empty array.")            return        }        self.notifications = decoded.sorted { $0.date > $1.date } // Load and sort        print("NS: Loaded \(self.notifications.count) notifications from UserDefaults.")    }        func save() {        if let encoded = try? JSONEncoder().encode(notifications) {            UserDefaults.standard.set(encoded, forKey: userDefaultsKey)            print("NS: Saved \(notifications.count) notifications to UserDefaults. Data: \(String(data: encoded, encoding: .utf8) ?? "nil")")        } else {            print("NS: Failed to encode notifications for saving.")        }    }        func markAsSeen(_ notification: AppNotification) {        guard let index = notifications.firstIndex(where: { $0.id == notification.id }) else { return }        if !notifications[index].isSeen {            notifications[index].isSeen = true            save()        }    }    func clearAll() {        notifications.removeAll()        UserDefaults.standard.removeObject(forKey: userDefaultsKey)        print("NS: Cleared all notifications and UserDefaults.")    }    var unseenCount: Int {        notifications.filter { !$0.isSeen }.count    }    func markAllAsSeen() {        var changed = false        for index in notifications.indices {            if !notifications[index].isSeen {                notifications[index].isSeen = true                changed = true            }        }        if changed {            save()        }    }}