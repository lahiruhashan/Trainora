////  NotificationManager.swift//  Trainora////  Created by user266021 on 5/4/25.//import Foundationimport UserNotificationsextension Notification.Name {    static let didReceiveAppNotification = Notification.Name("didReceiveAppNotification")}final class NotificationManager: NSObject {    static let shared = NotificationManager()    private override init() {        super.init()        UNUserNotificationCenter.current().delegate = self    }    func requestAuthorization() {        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in            if let error = error {                print("Notification permission error: \(error.localizedDescription)")            } else {                print("Notification permission granted: \(granted)")                if granted {                    DispatchQueue.main.async {                        // Register for remote notifications if you plan to use them                        // UIApplication.shared.registerForRemoteNotifications()                    }                }            }        }    }    // --- Reminder Notifications ---    func scheduleDailyReminder(at time: Date) {        let content = UNMutableNotificationContent()        content.title = "Trainora Reminder"        content.body = "Time to get moving! Check your workout planner ðŸ’ª"        content.sound = .default        content.userInfo = ["notification_type": AppNotificationType.reminder.rawValue] // Ensure userInfo is set        let triggerDate = Calendar.current.dateComponents([.hour, .minute], from: time)        let trigger = UNCalendarNotificationTrigger(dateMatching: triggerDate, repeats: true)        let request = UNNotificationRequest(identifier: AppNotificationType.reminder.rawValue, content: content, trigger: trigger)        print("Scheduling reminder with ID: \(request.identifier)")        UNUserNotificationCenter.current().add(request) { error in            if let error = error {                print("Failed to schedule reminder: \(error.localizedDescription)")            } else {                print("printed notification: \(request.identifier)")            }        }    }    func cancelReminder() {        UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [AppNotificationType.reminder.rawValue])        print("Cancelled reminder notifications")    }    func updateReminder(enabled: Bool, time: Date) {        if enabled {            scheduleDailyReminder(at: time)        } else {            cancelReminder()        }    }    // --- Diet Notifications ---    func scheduleDietNotification(type: AppNotificationType, hour: Int, minute: Int, title: String, body: String) {        let content = UNMutableNotificationContent()        content.title = title        content.body = body        content.sound = .default        content.userInfo = ["notification_type": type.rawValue] // Ensure userInfo is set        var triggerDate = DateComponents()        triggerDate.hour = hour        triggerDate.minute = minute        let trigger = UNCalendarNotificationTrigger(dateMatching: triggerDate, repeats: true)        let identifier = type.rawValue        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)        print("Scheduling diet notification with ID: \(identifier), Title: \(title)")        UNUserNotificationCenter.current().add(request) { error in            if let error = error {                print("Failed to schedule diet notification (\(identifier)): \(error.localizedDescription)")            } else {                print("Successfully scheduled diet notification: \(identifier)")            }        }    }    func cancelDietNotifications() {        let identifiers = [            AppNotificationType.dietBreakfast.rawValue,            AppNotificationType.dietLunch.rawValue,            AppNotificationType.dietDinner.rawValue        ]        UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: identifiers)        print("Cancelled all diet notifications")    }    func scheduleAllDietNotifications() {        print("Attempting to schedule all diet notifications...")        scheduleDietNotification(            type: .dietBreakfast,            hour: 23,            minute: 55,            title: "Breakfast Reminder",            body: "Don't skip the most important meal of the day! ðŸ³"        )        scheduleDietNotification(            type: .dietLunch,            hour: 23,            minute: 45,            title: "Lunch Reminder",            body: "It's lunchtime! Keep your energy up. ðŸ¥—"        )        scheduleDietNotification(            type: .dietDinner,            hour: 23, // Keeping the 22:50 as in your original code            minute: 50,            title: "Dinner Reminder",            body: "Wind down your day with a healthy dinner ðŸ½"        )    }    func scheduleInactivityNotificationIfNeeded(lastActiveDate: Date) {        let now = Date()        let diff = Calendar.current.dateComponents([.day], from: lastActiveDate, to: now).day ?? 0        print("Checking for inactivity: last active \(lastActiveDate), diff \(diff) days")        if diff >= 5 {            postInAppNotification(type: .inactivity, title: "We Miss You!", body: "It's been over 5 days since your last visit. Come back and train! ðŸ’ª")        }    }    func notifyAppUpdateAvailable() {        postInAppNotification(type: .appUpdate, title: "Update Available", body: "A new version of Trainora is ready with exciting features. Update now! ðŸš€")    }    private func postInAppNotification(type: AppNotificationType, title: String, body: String) {        let appNotification = AppNotification(            id: UUID(),            type: type,            title: title,            body: body,            date: Date(),            isSeen: false        )        NotificationStore.shared.addAndSave(appNotification) // Direct save for in-app notifications too    }    // Helper to create AppNotification    private func createAppNotification(from content: UNNotificationContent, identifier: String, deliveryDate: Date) -> AppNotification {        var notificationType: AppNotificationType = .reminder // Default        if let rawType = content.userInfo["notification_type"] as? String,           let type = AppNotificationType(rawValue: rawType) {            notificationType = type        } else if let type = AppNotificationType(rawValue: identifier) { // Fallback to identifier            notificationType = type        }        return AppNotification(            id: UUID(),            type: notificationType,            title: content.title,            body: content.body,            date: deliveryDate,            isSeen: false        )    }}extension NotificationManager: UNUserNotificationCenterDelegate {    // Called when app is in the foreground and a notification arrives    func userNotificationCenter(        _ center: UNUserNotificationCenter,        willPresent notification: UNNotification,        withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void    ) {        let content = notification.request.content        let identifier = notification.request.identifier        print("NM: willPresent notification with ID: \(identifier), Title: \(content.title)")        let appNotification = createAppNotification(from: content, identifier: identifier, deliveryDate: Date())        NotificationStore.shared.addAndSave(appNotification) // Direct save        completionHandler([.banner, .sound, .badge])    }    // Called when user interacts with a notification (taps it)    // This is CRUCIAL for saving notifications that arrive when app is not in foreground    func userNotificationCenter(        _ center: UNUserNotificationCenter,        didReceive response: UNNotificationResponse,        withCompletionHandler completionHandler: @escaping () -> Void    ) {        let notification = response.notification        let content = notification.request.content        let identifier = notification.request.identifier        print("NM: didReceive response for notification with ID: \(identifier), Title: \(content.title)")        let appNotification = createAppNotification(from: content, identifier: identifier, deliveryDate: notification.date)        NotificationStore.shared.addAndSave(appNotification) // Direct save        completionHandler()    }}