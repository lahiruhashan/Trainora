////  NotificationManager.swift//  Trainora////  Created by user266021 on 5/4/25.//import Foundationimport UserNotificationsimport CoreDatafinal class NotificationManager: NSObject {    static let shared = NotificationManager()    private override init() {        super.init()        UNUserNotificationCenter.current().delegate = self        syncDeliveredNotifications()    }    // Ask the user for permission to show alerts, play sounds, and badge the app icon.    func requestAuthorization() {        UNUserNotificationCenter.current()            .requestAuthorization(options: [.alert, .sound, .badge]) {                granted,                error in                if let error = error {                    print("Notification auth error:", error)                } else {                    print("Notification auth granted:", granted)                }            }    }    // Exercise Reminder    func scheduleExerciseReminder(at time: Date) {        let content = UNMutableNotificationContent()        content.title = "Workout Time!"        content.body = "Let's do your daily exercise ðŸ’ª"        content.userInfo = [            "notification_type": AppNotificationType.exercise.rawValue        ]        content.sound = .default        let comps = Calendar.current.dateComponents(            [.hour, .minute],            from: time        )        let trigger = UNCalendarNotificationTrigger(            dateMatching: comps,            repeats: true        )        let id = AppNotificationType.exercise.rawValue        let request = UNNotificationRequest(            identifier: id,            content: content,            trigger: trigger        )        UNUserNotificationCenter.current().add(request) { error in            if let err = error {                print("Failed to schedule exercise reminder:", err)            } else {                print(                    "Exercise reminder scheduled at \(comps.hour!):\(String(format: "%02d", comps.minute!))"                )            }        }    }    func cancelExerciseReminder() {        let id = AppNotificationType.exercise.rawValue        UNUserNotificationCenter.current().removePendingNotificationRequests(            withIdentifiers: [id])        print("Cancelled exercise reminder")    }    // Diet Reminders (hardâ€coded)    func scheduleDietReminders() {        let specs: [(AppNotificationType, Int, Int, String, String)] = [            (                .breakfast, 07, 00, "Breakfast Reminder",                "ðŸ³ Start your day right with a tasty breakfast."            ),            (                .lunch, 12, 00, "Lunch Reminder",                "ðŸ¥— Itâ€™s lunchtime! Refuel with a balanced meal."            ),            (                .dinner, 18, 30, "Dinner Reminder",                "ðŸŒ™ Dinner time! Unwind with a wholesome evening meal."            ),        ]        for (type, hour, minute, title, body) in specs {            let content = UNMutableNotificationContent()            content.title = title            content.body = "It's time for your \(title.lowercased()). \n\(body)"            content.userInfo = ["notification_type": type.rawValue]            content.sound = .default            var comps = DateComponents()            comps.hour = hour            comps.minute = minute            let trigger = UNCalendarNotificationTrigger(                dateMatching: comps,                repeats: true            )            let request = UNNotificationRequest(                identifier: type.rawValue,                content: content,                trigger: trigger            )            UNUserNotificationCenter.current().add(request) { error in                if let err = error {                    print("Failed to schedule \(type) reminder:", err)                } else {                    print(                        "Scheduled \(type) at \(hour):\(String(format: "%02d", minute))"                    )                }            }        }    }    func cancelDietReminders() {        let ids = [            AppNotificationType.breakfast,            AppNotificationType.lunch,            AppNotificationType.dinner,        ]        .map(\.rawValue)        UNUserNotificationCenter.current().removePendingNotificationRequests(            withIdentifiers: ids        )        print("Cancelled all diet reminders")    }    //  Core Data Persistence    // Convert UNNotificationContent to Notification model    private func makeAppNotification(        from content: UNNotificationContent,        identifier: String,        deliveryDate: Date    ) -> NotificationModel {        let rawType = content.userInfo["notification_type"] as? String        let type =            AppNotificationType(rawValue: rawType ?? "")            ?? .exercise        return NotificationModel(            id: UUID(),            type: type,            title: content.title,            body: content.body,            date: deliveryDate,            isSeen: false        )    }    // At launch, grab all alreadyâ€delivered notifications and persist them.    private func syncDeliveredNotifications() {        UNUserNotificationCenter.current()            .getDeliveredNotifications { [weak self] delivered in                delivered.forEach { unNotif in                    let content = unNotif.request.content                    let id = unNotif.request.identifier                    let date = unNotif.date                    let appNotif = self?.makeAppNotification(                        from: content,                        identifier: id,                        deliveryDate: date                    )                    if let n = appNotif {                        self?.persistToCoreData(n)                    }                }            }    }    // Persist the given AppNotification on a background Core Data context    private func persistToCoreData(_ notification: NotificationModel) {        let container = PersistenceController.shared.container        let bgContext = container.newBackgroundContext()        bgContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy        bgContext.perform {            let entity = NotificationEntity(context: bgContext)            entity.id = notification.id            entity.type = notification.type.rawValue            entity.title = notification.title            entity.body = notification.body            entity.date = notification.date            entity.isSeen = notification.isSeen            do {                try bgContext.save()                print(                    "Saved notification \(notification.title) at \(notification.date)"                )            } catch {                print("Failed saving notification:", error)            }        }    }}extension NotificationManager: UNUserNotificationCenterDelegate {    // App in foreground    func userNotificationCenter(        _ center: UNUserNotificationCenter,        willPresent notification: UNNotification,        withCompletionHandler handler:            @escaping (UNNotificationPresentationOptions) -> Void    ) {        let appNotif = makeAppNotification(            from: notification.request.content,            identifier: notification.request.identifier,            deliveryDate: Date()        )        persistToCoreData(appNotif)        handler([.banner, .sound, .badge])    }    // App in background or user tapped    func userNotificationCenter(        _ center: UNUserNotificationCenter,        didReceive response: UNNotificationResponse,        withCompletionHandler handler: @escaping () -> Void    ) {        let notif = response.notification        let appNotif = makeAppNotification(            from: notif.request.content,            identifier: notif.request.identifier,            deliveryDate: notif.date        )        persistToCoreData(appNotif)        handler()    }}