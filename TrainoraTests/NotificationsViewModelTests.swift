////  NotificationsViewModelTests.swift//  Trainora////  Created by user266021 on 5/7/25.//import XCTestimport CoreData@testable import Trainorafinal class NotificationsViewModelTests: XCTestCase {    var container: NSPersistentContainer!    var context: NSManagedObjectContext!    override func setUp() {        super.setUp()        container = NSPersistentContainer(name: "Trainora")        let desc = NSPersistentStoreDescription()        desc.type = NSInMemoryStoreType        container.persistentStoreDescriptions = [desc]        container.loadPersistentStores { description, error in            XCTAssertNil(error)        }        context = container.viewContext    }    override func tearDown() {        context = nil        container = nil        super.tearDown()    }    // Helper to insert a NotificationEntity    private func insertEntity(        id: UUID,        type: AppNotificationType,        title: String,        body: String,        date: Date,        isSeen: Bool    ) {        let entity = NotificationEntity(context: context)        entity.id = id        entity.type = type.rawValue        entity.title = title        entity.body = body        entity.date = date        entity.isSeen = isSeen    }    private func saveContext() {        do {            try context.save()        } catch {            XCTFail("Failed to save context: \(error)")        }    }    func test_fetchNotifications_populatesAndSortsByDateDescending() {        // Arrange        let now = Date()        let earlier = now.addingTimeInterval(-1000)        let later = now.addingTimeInterval(1000)        let id1 = UUID()        let id2 = UUID()        let id3 = UUID()        insertEntity(            id: id1,            type: .exercise,            title: "A",            body: "a",            date: earlier,            isSeen: false        )        insertEntity(            id: id2,            type: .breakfast,            title: "B",            body: "b",            date: later,            isSeen: true        )        insertEntity(            id: id3,            type: .lunch,            title: "C",            body: "c",            date: now,            isSeen: false        )        saveContext()        // Act        let vm = NotificationsViewModel(context: context)        // Assert        let models = vm.notifications        XCTAssertEqual(models.count, 3)        // Expect sorted: later (id2), now (id3), earlier (id1)        XCTAssertEqual(models.map { $0.id }, [id2, id3, id1])        XCTAssertEqual(models[0].type, .breakfast)        XCTAssertEqual(models[0].isSeen, true)    }    func test_toggleSeen_flipsIsSeenInStore_andUpdatesPublished() {        // Arrange        let date = Date()        let id = UUID()        insertEntity(            id: id,            type: .exercise,            title: "T",            body: "t",            date: date,            isSeen: false        )        saveContext()        let vm = NotificationsViewModel(context: context)        XCTAssertFalse(vm.notifications[0].isSeen)        // Act        vm.toggleSeen(vm.notifications[0])        // Assert Core Data changed        let fetch: NSFetchRequest<NotificationEntity> =            NotificationEntity.fetchRequest()        fetch.predicate = NSPredicate(format: "id == %@", id as CVarArg)        do {            let results = try context.fetch(fetch)            XCTAssertEqual(results.count, 1)            XCTAssertTrue(results[0].isSeen)        } catch {            XCTFail("Fetch failed: \(error)")        }        // Assert published array updated        XCTAssertTrue(vm.notifications.first!.isSeen)    }    func test_clearAll_removesAllEntities_andEmptiesPublished() {        // Arrange        insertEntity(            id: UUID(),            type: .dinner,            title: "D",            body: "d",            date: Date(),            isSeen: false        )        insertEntity(            id: UUID(),            type: .lunch,            title: "L",            body: "l",            date: Date(),            isSeen: true        )        saveContext()        let vm = NotificationsViewModel(context: context)        XCTAssertEqual(vm.notifications.count, 2)        // Act        vm.clearAll()        // Assert published array is empty        XCTAssertTrue(vm.notifications.isEmpty)        // Assert Core Data store is empty        let allFetch: NSFetchRequest<NotificationEntity> =            NotificationEntity.fetchRequest()        do {            let results = try context.fetch(allFetch)            XCTAssertTrue(results.isEmpty)        } catch {            XCTFail("Fetch after clear failed: \(error)")        }    }}